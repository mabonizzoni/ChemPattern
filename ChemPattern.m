(* ::Package:: *)

(* ::Section::Initialization:: *)
(*The Bonizzoni group LDA functions package*)


(* ::Input:: *)
(*(* The following forces the automatic generation / overwriting of an .m package file from this file every time this file is saved. *)*)
(*SetOptions[InputNotebook[],AutoGeneratedPackage->Automatic]*)


(* ::Input::Initialization:: *)
BeginPackage["lda`"]

Unprotect[lda,groupcontribs,outlierPCA,outlierPCAauto,plotsfromgrid,selectVarSubsets,filterVars,retainedInfo,effectOfRemovingVariables,pca,removeOutliers,overview,projectorLDA];
ClearAll[lda,groupcontribs,outlierPCA,outlierPCAauto,plotsfromgrid,selectVarSubsets,filterVars,retainedInfo,effectOfRemovingVariables,pca,removeOutliers,overview,projectorLDA];


(* ::Input::Initialization:: *)
lda::usage="lda[dataset] carries out Linear Discriminant Analysis on dataset and returns the transformed data as factor scores (default), or other numerical / graphical results. Each row of dataset should contain a sample; the first column contains the class identifier for that sample.\nOptions:\napplyfunc (Identity, Standardize (default), Rescale, ...)\noutput (\"scores\", \"vartable\", \"varlist\", \"eigenvectors\", \"eigensystem\", \"2D\" (= 2D score plot), \"2DL\" (= 2D score and loading plots, default), \"3D\", \"3DL\")\nswapaxes (default = {False,False})\nellipsoidcolor (Automatic, True).";

groupcontribs::usage="groupcontribs[eigensystem,numberofgroups,sensornames]\ngroupcontribs[eigensystem,numberofgroups]\nThe function generates a bar chart of the contributions of each group of variables to the overall discrimination. Before summing, the contributions to each factor are weighted by the corresponding eigenvalue of the factor. This is needed so that a group that contributes a lot to an unimportant factor is still reported as unimportant in the overall discrimination.";

outlierPCA::usage="outlierPCA[fullDataSet] runs PCA analysis on each set of replicates for samples in a full analytical data set (i.e. a plate), to help in the detection of outliers.\nIt expects the first row of the dataset to contain instrumental variable names, and the first column to contain text labels for each sample.";

outlierPCAauto::usage="outlierPCAauto[fullDataSet] runs PCA analysis on each set of replicates for samples in a full analytical data set (i.e. a plate), then identifies the points that lie outside of the 90% ellipsoid. Depending on the value of the output option, it can return: \n\toutput -> \"Plots\"\t\t scatter plots of replicates for each sample in which likely outliers are identified in red;\n\t\t\t\t\t      the plots also include the new 90% ellipsoid that would result from removal of the possible outliers.\n\toutput -> \"Lists\"\t\t  a classified list of points, divided between \"inliers\" (\"in\") and \"outliers\" (\"out\")\n\toutput -> \"OutlierLists\"\t  lists of the positions of replicates identified as possible outliers in each set\n\toutput -> \"CleanedSet\"\ta new dataset with outliers removed";

plotsfromgrid::usage="plotsfromgrid[graphicalResultsFromLDA] returns a list of two plots from the grouped scores / loadings plots generated by LDA, so one can easily extract the loadings plot";

selectVarSubsets::usage="selectVarSubsets[dataset, \"criterion string\"] selects a homogeneous subset of instrumental variable for analysis.\n Examples may be selection of all absorbance variables (e.g. criterion = \"Abs\", all the variables measured at a certain wavelength (e.g. criterion = \"450\"), etc.";

filterVars::usage="filterVars[dataset] starts an interactive session to explore variable removal from LDA analysis of dataset. Move the threshold bar with the mouse to change the variable selection threshold.\nfilterVars[dataset, threshold] returns non-interactive results obtained by removing variables whose contribution is less than the indicated threshold.\nfilterVars[dataset, threshold, output -> \"ReducedSet\"] returns a reduced data set obtained by removing variables whose contribution is less than the indicated threshold.";

retainedInfo::usage="retainedInfo[dataset] calculates the % information retained as a function of filtering threshold\n\toutput -> \"Plot\"\treturns the data as a plot (default)\n\toutput -> \"List\"\t returns the results as a list of {threshold, % information retained}";

effectOfRemovingVariables::usage="effectOfRemovingVariables[dataset, maxValueForThreshold, numberOfSteps] progressively removes variables that contribute less than a certain threshold and recomputes the LDA score plot on the reduced set; the function depends on lda and filterVars for its internal computation.\n\tmaxValueForThreshold\ttoo high a value may leave only one variable, or none, and will generate errors as LDA fails\t(default = 15 if omitted)\n\tnumberOfSteps\t\tthe number of computed lda scores plots across the range 0 -> maxValueForThreshold\t       (default = 3 if omitted)";

pca::usage="pca[dataset] performs PCA analysis on the data in dataset after standardization";

removeOutliers::usage="removeOutliers[dataset][{\"Sample1\", {1, 2, 4, ..}}, {\"Sample2\", {2, 5, 4, ..}}, ..]";

overview::usage="overview[dataset]\nThis function produces quick visual aids to examine the quality of information conveyed by each instrumental variable in a dataset.\nThe visualization is inspired by sparklines (i.e. no axes, no ticks).";

projectorLDA::usage="projectorLDA[originalDataSet,(\"suffix to add to original data set labels\"),datasetToBeProjected,(\"suffix to add to projected data set labels\")]\nThis function projects points from the second data set according to the transformation ruls obtained by standard LDA on the first data set.";


(* ::Section::Initialization:: *)
(*Implementation code below*)


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Section::Initialization:: *)
(*Functional implementation of LDA*)


(* ::Subsection::Initialization:: *)
(*Steps accomplished by the code below, in order:*)


(* ::Text::Initialization:: *)
(*check whether to normalize full data set column-wise*)
(*generate a series of subsets by using the labels in the first column to gather data by its class*)
(*calculate within class scatter for each class (Swi) and sum them up to give total within-class scatter (Sw): \!\(\*UnderscriptBox[\(\[Sum]\), \(sets\)]\)\!\(\*UnderscriptBox[\(\[Sum]\), \(samples\ in\ a\ set\)]\)(x-Subscript[\!\(\*OverscriptBox[\(x\), \(_\)]\), set])\[CenterDot](x-Subscript[\!\(\*OverscriptBox[\(x\), \(_\)]\), set])^T*)
(*calculate between class scatter (Sb): \!\(\*UnderscriptBox[\(\[Sum]\), \(sets\)]\)(Subscript[\!\(\*OverscriptBox[\(x\), \(_\)]\), set]-Subscript[\[Mu], global])\[CenterDot](Subscript[\!\(\*OverscriptBox[\(x\), \(_\)]\), set]-Subscript[\[Mu], global])^T*)
(*solve eigensystem of matrix Sw^-1\[CenterDot]Sb*)
(*plot transformed dataset in 2D with tooltips*)
(*return eigensystem*)


(* ::Subsection::Initialization:: *)
(*Implementation*)


(* ::Input::Initialization:: *)
Options[lda]={applyfunc->Standardize,output->"2DL",ellipsoidcolor->Automatic,swapaxes->False};

lda::outputoptions="The value `1` is not a valid plotting option. Valid options are: \"2DL\" (default), \"2D\", \"3DL\", \"3D\", \"scores\", \"eigenvectors\", \"eigensystem\", \"vartable\", \"varlist\".";
lda::swapaxesnotboolean="The value `1` is not a valid swapaxes option. Use only True / False or combinations thereof.";
lda::swapaxeslength="The value `1` given for the swapaxes option is not valid. Acceptable values are a single True / False, to be applied to all axes, or a list containing as many True/False values as there are axes in the requested plot.";
lda::ellcolor="The value `1` for the ellipsoidcolor option is not valid. Acceptable values are: Automatic, True, False. Automatic settings were used.";

lda[matrix_?MatrixQ,OptionsPattern[]]:=Module[
{(* the definition below is important, although it looks silly!*)
(* If one used matrix directly in the function body, the VALUE of matrix would be substituted *)
(* everywhere BEFORE any further evaluation. the name of the pattern is not a proper variable!! *)
(* This is the reason why the standardization in place did not work before *)
dataset=matrix,

(* other local variables*)
hascolumnheaders,columnheaderlist,classlist,
partitioneddata,transformeddata,labeledtransformed,partitionedscores,
grandmean,clustermeans,Swi,Sw,Sb,
eigenvals,eigenvecs,
plotdata,readyforplot,
ellipsoids2D,coloredellipsoids2D,
ellipsoids3D,coloredellipsoids3D,
(* this longer color list was introduced when I ran the acetate and chloride LDA, which had many groups and the function ran out of colors *)
colorlist=Join[ColorData[97,"ColorList"],Lighter@ColorData[97,"ColorList"],Lighter@ColorData[99,"ColorList"]]
},

(* if column headers are present, extract them and assign them to columnheaderlist. *)
(* if not, create a generic columnheaderlist and add it to the top of the dataset *)
(* this simplifies manipulation later on because we can assume the presence of column headers *)
(* and don't need to repeatedly check, no matter whether the original data had them or not *)
(* Remember that from now on dataset[[1,1]] contains no intereseting data *)
If[VectorQ[dataset[[1,2;;]],NumberQ]==True,
hascolumnheaders=False;PrependTo[dataset,Join[{""},columnheaderlist=ToString/@Array["var",Last@Dimensions@dataset-1]]],
hascolumnheaders=True;columnheaderlist=dataset[[1,2;;]]
];

(* extract the class list from the first column in the dataset; remember that the first row is the column headers *)
classlist=DeleteDuplicates[dataset[[2;;,1]]];

(* Apply the applyfunc function to the numerical part of the dataaset *)
(* applyfunction's default is Identity, i.e. do nothing; if standardization is desired, *)
(* an appropriate standardizing function (e.g. Standardize itself) can be passed in *)
dataset[[2;;,2;;]]=OptionValue[applyfunc][dataset[[2;;,2;;]]];

(* Row headers are used as class labels to partition the data into the user-specified classes *)
(* The first row of dataset contains the column headers so it is ignored here *)
(* The class labels are then removed before assigning the list of partitioned datasets to partitioneddata *)
partitioneddata=GatherBy[dataset[[2;;]],First][[All,All,2;;]];

(* Calculate the within-cluster scatter by applying the Swi function to each cluster, and summing up each cluster's contribution *)
Swi[set_]:=Total[Map[Transpose[{#-Mean[set]}] . {#-Mean[set]}&,set]];
Sw=Total[Map[Swi,partitioneddata]];

(* Calculate the between-cluster scatter *)
(* In the case of a standardized dataset, the grand mean, i.e. the column-wise mean over the entire dataset should be exactly zero *)(* However it will typically calculate out to very small non-zero numbers at machine precision. To avoid accumulating inaccuracies, *)
(* the grand mean is chopped. If the dataset is not standardized, chopping has no significant effect *)
grandmean=Chop@Mean[dataset[[2;;,2;;]]];
clustermeans=Map[Mean,partitioneddata];
Sb=Total[Map[(Transpose[{#-grandmean}] . {#-grandmean}&),clustermeans]];

(* Maximize the Sb/Sw ratio by solving the equivalent eigenproblem *)
(* The Check[] wrapper around Inverse stops computation and returns if the inverse cannot be computed, e.g. for singular matrices *)
(*old Implementation:*)
(*{eigenvals,eigenvecs}=Chop@Eigensystem[Check[Inverse[Sw].Sb,Abort[],{Inverse::sing}]];*)
{eigenvals,eigenvecs}=Chop@Eigensystem[LinearSolve[Sw,Sb]];

(* Calculate data scores along the LDA dimensions *)
transformeddata=Chop[dataset[[2;;,2;;]] . Transpose@eigenvecs];

(* Add back the column and row headers to the transformed data *)
labeledtransformed=Prepend[dataset[[1]]][Transpose@Insert[Transpose@transformeddata,dataset[[2;;,1]],1]];

Which[

(********************)
(* Numerical output *)
(********************)

OptionValue[output]=="scores",(* Return the transformed data as labeled scores, e.g. for external plotting *)
Return[
Transpose@Prepend[
(* Add the ROW headers from the original dataset back in *)
Transpose@Prepend[
(* Add the factor number COLUMN headers *)
transformeddata,Array["F"<>ToString[#]&,Dimensions[transformeddata][[2]] ]
],
dataset[[All,1]]
]
],

OptionValue[output]=="vartable",(* Return a formatted table of the contributions of each variable to the first three factors *)
Return[
Style[
TableForm[Transpose@Round[100eigenvecs[[1;;3]]^2,1],TableHeadings->{columnheaderlist, {"F1","F2","F3"}},TableAlignments->Right],
FontFamily->"Arial",FontSize->14
]
],

OptionValue[output]=="varlist",(* Return the contributions of each variable to the first three factors as above, but WITHOUT formatting *)
Return[
Transpose@Join[{columnheaderlist}, Round[100eigenvecs^2,1]]
],

OptionValue[output]=="eigenvectors",(* Return eigenvector matrix *)
Return[eigenvecs],

OptionValue[output]=="eigensystem", (* Return the list: {eigenvalues,eigenvectors} *)
Return[{eigenvals,eigenvecs}],

(***************)
(* 2D PLOTTING *)
(***************)

OptionValue[output]=="2D"||OptionValue[output]=="2DL",(* 2D plot of results was requested *)
plotdata=labeledtransformed[[All,1;;3]];

(* Swap values along x or y axes if requested; default is to do nothing *)
Module[
{xflip,yflip},
Switch[Length@OptionValue[swapaxes],

0, (* Atomic expression, i.e. a single value was passed *)
Switch[OptionValue[swapaxes],
True,xflip=yflip=-1,(* swap both axes *)
False,xflip=yflip=1,(* don't swap any axis *)
_,(* incorrect option; throw error and return Null *)Message[lda::swapaxesnotboolean,OptionValue[swapaxes]];Return[]
],

1,(* a list with one element; this is ambiguous and may be a syntax error on the part of the user; throw error *)
Message[lda::swapaxeslength,OptionValue[swapaxes]];Return[],

2,(* a list of two values*)
If[Not[BooleanQ@OptionValue[swapaxes][[1]]&&BooleanQ@OptionValue[swapaxes][[2]]],Message[lda::swapaxesnotboolean,OptionValue[swapaxes]];Return[]];
xflip=If[OptionValue[swapaxes][[1]]===True,-1,1];
yflip=If[OptionValue[swapaxes][[2]]===True,-1,1],

_,(* too many parameters for a 2D plot; possibly ambiguous *)
Message[lda::swapaxeslength,OptionValue[swapaxes]];Return[]
];

plotdata=plotdata/.List[class_?StringQ,x_?NumberQ,y_?NumberQ]->List[class,xflip x,yflip y]
];

(* Ellipsoids: in a non-correlated binormal distribution, 90% of the points lie within 2.15 standard deviations of the mean; 95% within 2.45 stdev; 99% within 3 stdev; 99.5% within 3.25 stdev *)
(* The ellipsoids are expressed as a function of the covariance; so n times StDev = n^2 times Covariance *)
(* To plot 95% confidence ellipsoids we need to stay within 2.45 stdev = (2.45)^2 covariance = ca. 6 covariance *)
partitionedscores=GatherBy[plotdata[[2;;]],First][[All,All,2;;3]];
ellipsoids2D={Opacity[0],EdgeForm[{Darker@Gray}],Ellipsoid[Mean[#],6Covariance[#]]}&/@partitionedscores;
coloredellipsoids2D=MapThread[
{Opacity[0],EdgeForm[{#2,AbsoluteThickness[2]}],Ellipsoid[Mean[#1],6Covariance[#1]]}&,
{
partitionedscores,
colorlist[[1;;First@Dimensions@partitionedscores]]
}];

readyforplot=MapThread[Tooltip,{partitionedscores,classlist}];

Return[
If[OptionValue[output]=="2DL",GraphicsRow[#,ImageSize->Scaled[0.6]]&,Show[#[[1]],ImageSize->Scaled[0.3]]&]@
List[
(* 2D score plot *)
ListPlot[readyforplot,
Frame->True,Axes->False,FrameStyle->Directive[Black,FontSize->15],FrameLabel->{
Style["Factor 1 ("<>ToString[Round[100eigenvals[[1]]/Total@eigenvals,0.1]]<>"%)",FontSize->16,Blue],
Style["Factor 2 ("<>ToString[Round[100eigenvals[[2]]/Total@eigenvals,0.1]]<>"%)",FontSize->16,Red]
},
AspectRatio->1,PlotRange->All,PlotRangePadding->Scaled[0.10],
Epilog->Which[
OptionValue[ellipsoidcolor]===Automatic||OptionValue[ellipsoidcolor]===False,ellipsoids2D,
OptionValue[ellipsoidcolor]===True,coloredellipsoids2D,
True,Message[lda::ellcolor,OptionValue[ellipsoidcolor]];ellipsoids2D
]
],
If[OptionValue[output]=="2DL",
(* 2D loading plot *)
ListPlot[
MapThread[Labeled[100#1,Style[#2<>" "<>ToString@Round[100#1,1],Medium]]&,{Transpose[eigenvecs[[1;;2]]^2],columnheaderlist}],
PlotStyle->Directive[Black,PointSize[0.025]],
(* The aspect ratio and plotrange definitions below make the plot square, while still adapting the plot range to the values being plotted *)
AspectRatio->1,PlotRange->{{0,105Max[Transpose[eigenvecs[[1;;2]]^2]]},{0,105Max[Transpose[eigenvecs[[1;;2]]^2]]}},PlotRangePadding->Scaled[.05],
AxesOrigin->{0,0},
Frame->{True,True,False,False},FrameStyle->Directive[Black,FontSize->15],FrameLabel->{
Style["Contrib. to F1 (%)",FontSize->16,Blue],
Style["Contrib. to F2 (%)",FontSize->16,Red]
}
],
(* no 2D loading plot: add "nothing" *)
Unevaluated@Sequence[]
]
]
],

(***************)
(* 3D PLOTTING *)
(***************)

OptionValue[output]=="3D"||OptionValue[output]=="3DL",(* 3D plot of results was requested *)
plotdata=labeledtransformed[[All,1;;4]];

(* Swap values along x or y axes if requested; default is to do nothing *)
Module[
{xflip,yflip,zflip},
Switch[Length@OptionValue[swapaxes],

0, (* Atomic expression, i.e. a single value was passed *)
Switch[OptionValue[swapaxes],
True,xflip=yflip=zflip=-1,(* swap all axes *)
False,xflip=yflip=zflip=1,(* don't swap any axis *)
_,(* incorrect option; throw error and return Null *)Message[lda::swapaxesnotboolean,OptionValue[swapaxes]];Return[]
],

1,(* a list with one element; this is ambiguous and may be a syntax error on the part of the user; throw error *)
Message[lda::swapaxeslength,OptionValue[swapaxes]];Return[],

2,(* a list with two elements; not enough for a 3D plot; throw error *)
Message[lda::swapaxeslength,OptionValue[swapaxes]];Return[],

3,(* a list of three values*)
If[Not[BooleanQ@OptionValue[swapaxes][[1]]&&BooleanQ@OptionValue[swapaxes][[2]]&&BooleanQ@OptionValue[swapaxes][[3]]],Message[lda::swapaxesnotboolean,OptionValue[swapaxes]];Return[]];
xflip=If[OptionValue[swapaxes][[1]]===True,-1,1];
yflip=If[OptionValue[swapaxes][[2]]===True,-1,1];
zflip=If[OptionValue[swapaxes][[3]]===True,-1,1],

_,(* too many parameters for a 3D plot; possibly ambiguous *)
Message[lda::swapaxeslength,OptionValue[swapaxes]];Return[]
];

plotdata=plotdata/.List[class_?StringQ,x_?NumberQ,y_?NumberQ,z_?NumberQ]->List[class,xflip x,yflip y,zflip z]
];

(* Ellipsoids: see above in plot 2D for discussion of width of ellipsoids *)
partitionedscores=GatherBy[plotdata[[2;;]],First][[All,All,2;;4]];
ellipsoids3D={Opacity[0.1,Black],Ellipsoid[Mean[#],6Covariance[#]]}&/@partitionedscores;
coloredellipsoids3D=MapThread[
{Opacity[0.2,#2],Ellipsoid[Mean[#1],6Covariance[#1]]}&,
{
partitionedscores,
colorlist[[1;;First@Dimensions@partitionedscores]]
}];

readyforplot=MapThread[Tooltip[{#3,Point[#1]},#2]&,{partitionedscores,classlist,colorlist[[1;;First@Dimensions@partitionedscores]]}];

Return[
If[OptionValue[output]=="3DL",GraphicsRow[#,ImageSize->Scaled[1]]&,Show[#[[1]],ImageSize->Scaled[0.6]]&]@
List[
(* 3D score plot *)
Graphics3D[{
{PointSize->0.006,readyforplot},
Which[
OptionValue[ellipsoidcolor]===Automatic||OptionValue[ellipsoidcolor]===True,coloredellipsoids3D,
OptionValue[ellipsoidcolor]===False,ellipsoids3D,
True,Message[lda::ellcolor,OptionValue[ellipsoidcolor]];coloredellipsoids3D
]
},
Axes->True,AxesStyle->Black, BoxStyle->Black,
AxesLabel->{
Style["Factor 1 ("<>ToString[Round[100eigenvals[[1]]/Total@eigenvals,0.1]]<>"%)",FontSize->Scaled[0.04],FontFamily->"Arial",Blue],Style["Factor 2 ("<>ToString[Round[100eigenvals[[2]]/Total@eigenvals,0.1]]<>"%)",FontSize->Scaled[0.04],FontFamily->"Arial",Red],
Style["Factor 3 ("<>ToString[Round[100eigenvals[[3]]/Total@eigenvals,0.1]]<>"%)",FontSize->Scaled[0.04],FontFamily->"Arial",Darker@Green]
},
PlotRange->All,PlotRangePadding->Scaled[0.05],BoxRatios->{1, 1, 1},Lighting->"Neutral",RotationAction->"Clip"
],
If[OptionValue[output]=="3DL",
(* 3D loading plot *)
Graphics3D[
MapThread[Tooltip[Style[Point[#1],Red,PointSize[0.02]],Style[#2<>" "<>ToString@Round[100#1,1],Medium]]&,{Transpose[eigenvecs[[1;;3]]^2],columnheaderlist}],
PlotRange->{{0,1},{0,1},{0,1}},PlotRangePadding->Scaled[.05],
Axes->True,AxesStyle->Black, BoxStyle->Black,
AxesLabel->{
Style["Contrib. to F1",FontSize->Scaled[0.04],FontFamily->"Arial",Blue],
Style["Contrib. to F2",FontSize->Scaled[0.04],FontFamily->"Arial",Red],
Style["Contrib. to F3",FontSize->Scaled[0.04],FontFamily->"Arial",Darker@Green]
},
RotationAction->"Clip"
],
(* no 3D loading plot: add "nothing" *)
Unevaluated@Sequence[]
]
]
],

(************************************)
(* Default: incorrect output option *)
(************************************)

True,(* default option: if this is reached, the selected output option is incorrect, so throw error and return Null *)
Message[lda::outputoptions,OptionValue[output]];Return[]
];
]


(* This alternative definition of lda handles malformed input *)
lda::notamatrix="The input to lda is not a matrix.";
lda[dataset_/;Not[MatrixQ[dataset]],OptionsPattern[]]:=Message[lda::notamatrix]



(* ::Section::Initialization:: *)
(*Group contribution helper functions*)


(* ::Input::Initialization:: *)
(* The following function generates a bar chart of the weighted contributions of each sensor to the overall discrimination *)
(* The contributions are weighted by the weight of the factors themselves, represented by the eigenvalues from lda *)
(* This is because a sensor that contributes a lot to an unimportant factor is still unimportant in the overall discrimination *)

groupcontribs::numgroups="The number of variables in the eigensystem (`1`) is not an exact multiple of the number of groups provided (`2`).";

groupcontribs[eigensystem_,numberofgroups_,sensornames_:Null]:=Module[
{eigenvals=eigensystem[[1]],eigenvecs=eigensystem[[2]],variablespergroup,sqweightedeigenvecs,barvalues},

If[Mod[Length@eigenvecs,numberofgroups]==0,
variablespergroup=(Length@eigenvecs)/numberofgroups,
Message[groupcontribs::numgroups,Length@eigenvecs,numberofgroups];Abort[]
];

(* eigenvectors are weighted by the corresponding eigenvalues, then squared *)
sqweightedeigenvecs=(Normalize[eigenvals,Total]eigenvecs)^2;

barvalues=Round[100#,1]&@
Normalize[#,Total]&@
Table[
Chop@Total[sqweightedeigenvecs[[All,i;;variablespergroup-1+i]]^2,Infinity],
{i,1,Last@Dimensions@eigenvecs-variablespergroup+1,variablespergroup}];

BarChart[
barvalues,
ChartLabels->Map[Style[#,FontSize->20,Black]&,If[sensornames===Null,Array[group,(Last@Dimensions@eigenvecs)/variablespergroup],sensornames]],
BarSpacing->Large,
PlotLabel->Style["% contribution of each sensor (overall)",Black,FontFamily->"Arial",FontSize->20],
ImageSize->Scaled[0.25]
]
]


(* ::Section::Initialization:: *)
(*Detection of outliers using PCA*)


(* ::Subsection:: *)
(*The "manual" version: shows all-data ellipsoid, lets user choose outliers*)


(* ::Text:: *)
(*The old outlierPCA used calculated the principal components using the eigensystem of the correlation of the data. *)
(*This was always VERY fragile, and had recently become the least dependable link in the toolchain.*)
(**)
(*This function has been rewritten (2017-06-26) to use the built-in PrincipalComponents[]. The built-in is much more robust, probably because it implements SVD or similar.*)


(* ::Input::Initialization:: *)
ClearAll[iOutlierPCA]

outlierPCA[dataset_?(MatrixQ[#[[2;;,2;;]],NumberQ]&)]:=Module[{grouped},
grouped=If[NumberQ[dataset[[ 1,2]]],
{dataset},(* the first row contains data, not variable labels: keep it. Also, "grouped" must be a list of groups to map over, so wrap data in one more level of List *)
GatherBy[dataset[[2;;]],First](* the first row contains variable labels: discard it *)
];
iOutlierPCA/@grouped
]

(*The following worker function is passed each subset of data by the outlierPCA[] front-end function *)
iOutlierPCA[set_]:=Module[
{PCs,ellipsoids2D},
PCs=PrincipalComponents[set[[All,2;;]],Method->"Correlation"][[All,1;;2]];
Show[{
ListPlot[
MapIndexed[Labeled[#1,First@#2]&,PCs],
AspectRatio->1,PlotStyle->PointSize[0.02],
Axes->False,Frame->True,FrameStyle->Directive[Black,FontSize->14],
FrameTicks->None,(* Absolute values of the scores do not convey much meaning here, so I don't bother showing them *)
Epilog->Text[Style[set[[2,1]],Red,Bold,FontSize->18],Scaled[{0.99,0.95}],{1,0}]
],
Graphics@{Opacity[0],EdgeForm[{Gray,Dashed,Thick}],Ellipsoid[Mean@PCs,6Covariance@PCs]}
},
PlotRange->All,PlotRangePadding->Scaled[0.1],ImageSize->Medium
]
]


(* ::Subsection:: *)
(*The automated version (still slightly experimental)*)


(* ::Text:: *)
(*This version uses the same machinery as the manual one, but it shows the points outside of the original ellipsoid in red, then plots the data together with the ellipsoid that would be obtained if the alleged outliers were removed from the set.*)


(* ::Input::Initialization:: *)
Options[outlierPCAauto]={output->"Plots"};

outlierPCAauto[dataset_List?(MatrixQ[#[[2;;,2;;]],NumberQ]&),OptionsPattern[]]:=Module[{results},
results=Association@
KeyValueMap[
Function[{label,sampleset},label->iOutlierSelector[sampleset]],
GroupBy[First->Rest]@dataset[[2;;]](*Assume full dataset in input, so variable labels in first row are discarded*)
];

Switch[OptionValue[output],
"Plots",KeyValueMap[iOutlierPlotter,results],
"Lists",results,
"OutlierLists",Keys/@results[[All,"out"]],
"CleanedSet",iRemakeDataset[dataset,Keys/@results[[All,"in"]]],
_,(*option value not recognized*)Message[outlierPCAauto::usage]
]
]

(*Default definition to bring up a syntax error for incorrect usage*)
outlierPCAauto[__]:=Message[outlierPCAauto::usage]

ClearAll[iOutlierSelector]
iOutlierSelector[sampleset_]:=Module[{rawScores,labeledScores,ellipsoid,rmf,out,in},
rawScores=PrincipalComponents[sampleset,Method->"Correlation"][[All,;;2]];
labeledScores=Association@MapIndexed[First@#2->#1&,rawScores];
(*Values used below because apparently Covariance doesn't handle associations yet*)
ellipsoid=Ellipsoid[Mean[labeledScores],6Covariance[Values@labeledScores]];
rmf=RegionMember@ellipsoid;
out=Select[labeledScores,Not@*rmf];
in=Complement[labeledScores,out];
(*Return an association, with points grouped under labels "in" and "out"*)
<|"in"->in,"out"->out|>
]


ClearAll[iOutlierPlotter]
iOutlierPlotter[label_String,setOfReplicates_Association]:=Module[{plotdata,newEllipsoid},
(*set up data for plotting*)
(*The {} \[Rule] Nothing is there for those sets for which no outliers are found.*)
(*In those cases KeyValueMap will generate a trailing empty list*)
(*from the corresponding <|"out"\[Rule]{}|>, which needs to be removed before ListPlot*)
plotdata=(KeyValueMap[Labeled[#2,#1]&]/@setOfReplicates)/.{}->Nothing;

(*generate new ellipsoid for plotting*)
newEllipsoid=Ellipsoid[Mean[setOfReplicates["in"]],6Covariance[Values@setOfReplicates["in"]]];(*Values used here because apparently Covariance doesn't handle associations yet*)

(*generate plots*)
Framed@ListPlot[
plotdata,
PlotStyle->{Automatic,Directive[PointSize[0.02],Red]},
PlotRange->All,PlotRangePadding->Scaled[0.18],
Epilog->{FaceForm[None],EdgeForm[{Thick,Dashed,Darker@Gray}],newEllipsoid},
PlotLabel->Style[label,Bold,Red,18],
Axes->False,Frame->False,
AspectRatio->1,
PlotLegends->None,ImageSize->Medium
]
]

ClearAll[iRemakeDataset]
iRemakeDataset[dataset_,results_Association]:=Module[
{variableLabels,grouped,extractionList,goodReplicates},

variableLabels=dataset[[1]];
grouped=GroupBy[dataset[[2;;]],First->Rest];
extractionList=Map[List,results,{2}];
goodReplicates=MapThread[Extract[#1,#2]&,{grouped,extractionList}];
Join[
{variableLabels},
Flatten[#,1]&@
MapThread[
Function[{key,values},Map[Join[{key},#]&,values]],
Through[{Keys,Values}[goodReplicates]]
]
]
]


(* ::Section::Initialization:: *)
(*plotsfromgrid: helper function to extract the score and loading plots from a Grid output*)


(* ::Text::Initialization:: *)
(*This function returns a list of two objects: the first is the score plot; the second is the loading plot.*)


(* ::Input::Initialization:: *)
plotsfromgrid[gridobject_?(MemberQ[#,{Inset[__],Inset[__]},Infinity]&)]:=gridobject[[1,2,1,All,1]]
plotsfromgrid[nongridobject_]:=nongridobject


(* ::Section::Initialization:: *)
(*selectVarSubsets: helper function to select homogeneous instrumental variable subsets for analysis*)


(* ::Input::Initialization:: *)
selectVarSubsets[set_,criterion_]:=
Transpose@Insert[
Select[Transpose[set],StringContainsQ[#[[1]],criterion]&],
set[[All,1]],1
]


(* ::Section::Initialization:: *)
(*filterVars: helper function to use with Manipulate to interactively filter low-contribution variables to LDA*)


(* ::Input::Initialization:: *)
ClearAll[iFilterVars]

Options[filterVars]={output->"ReducedSet"};

filterVars::alldiscarded="The requested threshold is so high that all variables were removed from the dataset. Consider lowering it.";
filterVars::invopt="Incorrect option value; the only option allowed is output -> \"ReducedSet\".";

(* If function is called with only one argument, interactive manipulation is selected; the variable must be a dataset *)
filterVars[dataset_?(MatrixQ[#[[2;;,2;;]],NumberQ]&)]:=DynamicModule[
{threshold=0},(*Initially threshold is set to zero*)
Dynamic[
MapAt[(*MapAt wraps the bar chart received from iFilterVars in ClickPane and uses mouse clicks to adjust threshold*)
Function[plot,ClickPane[plot,(threshold=First@#)&]],
iFilterVars[dataset,threshold],
{1,2,1}(*position of the bar chart in the grid returned by iFilterVars*)
],
(*Only tracks changes in threshold; otherwise graphics are unresponsive and jittery*)
TrackedSymbols:>{threshold}
]
]

(* If function is called with two arguments, a dataset and a threshold, then a non-interactive single-value graphical results are returned *)
filterVars[dataset_?(MatrixQ[#[[2;;,2;;]],NumberQ]&),threshold_?NumericQ/;threshold>=0]:=iFilterVars[dataset,threshold]

(* If function is called with two arguments (i.e. dataset and threshold), and output \[Rule] "ReducedSet" is included, then a reduced data set is returned instead of graphical results *)
filterVars[dataset_?(MatrixQ[#[[2;;,2;;]],NumberQ]&),threshold_?NumericQ/;threshold>=0,OptionsPattern[]]:=Module[
{evals,evecs,assoc,selectedVars},

If[OptionValue[output]=!="ReducedSet",Message[filterVars::invopt];Abort[]];

{evals,evecs}=lda[dataset,applyfunc->Standardize,output->"eigensystem"];
assoc=AssociationThread[dataset[[1,2;;]],100Chop[Normalize[evals,Total] . evecs^2]];
selectedVars=Select[assoc,#>=threshold&];

(* Inform the user if the threshold is so high that all variables are discarded *)
If[Length[selectedVars]==0,Message[filterVars::alldiscarded]];

(*Collect and compile an output data set*)
Transpose@Join[{dataset[[All,1]]},Cases[Transpose@dataset,{Alternatives@@Keys[selectedVars],__}]]
]

(* Implementation code *)
iFilterVars[dataset_,threshold_]:=Module[
{assoc,selectedVars,selectedData,ldaplot,ldavarlist,bchart,evals,evecs},

{evals,evecs}=lda[dataset,applyfunc->Standardize,output->"eigensystem"];
assoc=AssociationThread[dataset[[1,2;;]],100Chop[Normalize[evals,Total] . evecs^2]];

selectedVars=Select[assoc,#>=threshold&];
selectedData=Transpose@Join[{dataset[[All,1]]},Cases[Transpose@dataset,{Alternatives@@Keys[selectedVars],__}]];

bchart=BarChart[
assoc,
BarOrigin->Left,ChartLabels->Automatic,BarSpacing->0.5,
ColorFunctionScaling->False,
ColorFunction->Function[{height},If[height>=threshold,Darker@Green,LightGray]],
AspectRatio->2,ImageSize->Large,
Prolog->{Dashing[0.02],Darker@Gray,Thick,HalfLine[{{threshold,0.3},{threshold,10}}]}
];

ldaplot=Show[
lda[selectedData,applyfunc->Standardize,output->"2D"],
ImageSize->Large];

ldavarlist=Reverse@SortBy[{#[[2]]&,#[[3]]&}]@lda[selectedData,applyfunc->Standardize,output->"varlist"][[All,1;;3]];

Grid[
{
(*formatting of titles: apply style only if argument is string; otherwise SpanFromLeft looks weird*)
Function[{s},If[Head[s]===String,Style[s,18,Black,FontFamily->"Trebuchet MS"],s]]/@
{"Original data set:",
SpanFromLeft,
"Filtered data set: (threshold = "<>ToString[Round[threshold,0.01]]<>")"},
{bchart,
selectedVars//Round[#,0.1]&//Sort//Reverse//Dataset,
ldaplot},
{SpanFromAbove,
Column[Style[#,Black,Bold,22]&/@{
"Retained:\n",
ToString@Length[selectedVars]<>" vars\n",
ToString@Round[Total@selectedVars,0.1]<>"% info"
},Right],
Multicolumn[ldavarlist,4(*organize results in four columns*)]}
},
Background->{None,None,{3,2}->LightGray},
Alignment->{Center,Center},
Dividers->{{3->Directive[Thick,Black]},{2->Directive[Thick,Black]}},
Spacings->{
(*x direction, add spacing btw table and new LDA plot's F2 axis label*){Automatic,3->Offset[1]},
(*y direction, add spacing btw titles and the new LDA plot's frame*){Automatic,2->Offset[1]}
}
]
]


(* ::Section:: *)
(*retainedInfo: a function to calculate the % retained information as a function of filter threshold*)


(* ::Input::Initialization:: *)
ClearAll[iRetainedInfo,iRetainedInfoPlot,iRetainedInfoList]

Options[retainedInfo]={output->"Plot"};

retainedInfo[dataset_,OptionsPattern[]]:=Module[{eigensystem},
eigensystem=lda[dataset,applyfunc->Standardize,output->"eigensystem"];
Switch[OptionValue[output],
"Plot",iRetainedInfoPlot[eigensystem],
"List",iRetainedInfoList[eigensystem],
_,Message[retainedInfo::usage];Abort[]
]
]

iRetainedInfo[{evals_,evecs_},threshold_]:=Module[
{infolist},
infolist=100Chop[Normalize[evals,Total] . evecs^2];
Quantity[Total@Select[infolist,#>=threshold&],"Percent"]
]

iRetainedInfoPlot[{evals_,evecs_}]:=Module[{maxthreshold},
maxthreshold=Max[100Chop[Normalize[evals,Total] . evecs^2]];
Plot[
iRetainedInfo[{evals,evecs},t],{t,0,maxthreshold},
PlotRange->{Automatic,100},PlotRangePadding->{Scaled[0.02],{2,2}},
Axes->False,Frame->{{True,False},{True,False}},
FrameTicks->{Automatic,{#,ToString[#]<>"%"}&/@Range[0,100,20]},
FrameStyle->Directive[Black,14],
FrameLabel->(Style[#,18]&/@{"threshold to discard variables","info retained in reduced system"}),
ImageSize->Large
]
]

iRetainedInfoList[{evals_,evecs_}]:=With[
{maxthreshold=Max[100Chop[Normalize[evals,Total] . evecs^2]]},
Table[{t,iRetainedInfo[{evals,evecs},t]},{t,0,maxthreshold,maxthreshold/200}]
]


(* ::Section:: *)
(*effectOfRemovingVariables*)


(* ::Text:: *)
(*A helper function that attempts to show graphically the effect of removing more and more variables from a dataset on the LDA scores plot. Since the function doesn't appear to be very useful, it is not currently not exported from the package. It is also not protected.*)


(* ::Input::Initialization:: *)
ClearAll[iEffectOfRemovingVariables]
Options[effectOfRemovingVariables]={output->"3D"};

effectOfRemovingVariables::syntax="incorrect syntax / argument count, or unrealistic argument value";

effectOfRemovingVariables[dataset_?MatrixQ,tmax_:15,numsteps_:3,OptionsPattern[]]/;(0<tmax<100&&numsteps>1):=Module[
{iterator={t,0,tmax,tmax/(numsteps-1)},assoclist,i},

assoclist=iEffectOfRemovingVariables[dataset,tmax,numsteps];

Switch[OptionValue[output],

"3D",
i=1;
Graphics3D[{
KeyValueMap[{ColorData[97][i++],Inset[Style[StringTake[#1,1],Bold,14],#2]}&,assoclist],
{Opacity[0.2],Table[InfinitePlane[{{t,0,0},{t,1,0},{t,1,1}}],Evaluate@iterator]}
},
PlotRange->All,PlotRangePadding->{0,Scaled[0.05],Scaled[0.05]},
AxesLabel->{Style["threshold",16,Black,Bold],"F1","F2"},
BoxRatios->{3, 1, 1},ImageSize->Large,
Lighting->{{"Ambient", Gray}},
Axes->True,AxesStyle->{Directive[Black,Bold,16],Automatic,Automatic}
],

"2D",
Replace[
KeyValueMap[
Framed@ListPlot[#2,PlotLabel->Style[#1,16,Red],PlotRange->All,Joined->True,Mesh->Full,Axes->False,AspectRatio->1]&,
assoclist[[All,All,2;;]]
],
Line[l_List]:>{Arrowheads->Medium,Arrow/@Partition[l,2,1]},
Infinity
],

_,Message[effectOfRemovingVariables::syntax];Message[effectOfRemovingVariables::usage]
]
]

iEffectOfRemovingVariables[dataset_,tmax_,numsteps_]:=Module[
{iterator={t,0,tmax,tmax/(numsteps-1)}},
Merge[Identity]@
Table[
Map[
Join[{t},#]&,
Mean/@GroupBy[First->Rest]@
lda[filterVars[dataset,t,output->"ReducedSet"],output->"scores"][[2;;,1;;3]]
],
Evaluate@iterator
]
]

effectOfRemovingVariables[___]:=(Message[effectOfRemovingVariables::syntax];Message[effectOfRemovingVariables::usage])



(* ::Section::Initialization:: *)
(*pca: a quick PCA helper function*)


(* ::Input::Initialization:: *)
pca[data_?MatrixQ]:=Module[
{
vars=data[[1,2;;]],
labels=data[[2;;,1]],
scores,annotated,scoregroups,
eigenvals
},

eigenvals=Eigenvalues@Correlation[data[[2;;,2;;]]];
scores=PrincipalComponents[data[[2;;,2;;]],Method->"Correlation"][[All,1;;2]];
annotated=Merge[Identity]@MapThread[
<|#1->Tooltip[#2,#1]|>&,
{labels,scores}
];
scoregroups=GatherBy[Transpose@Insert[Transpose@scores,labels,1],First][[All,All,2;;]];

Show[
Graphics[
{Opacity[0],EdgeForm[Black],Ellipsoid[Mean@#,6Covariance@#]}&/@scoregroups
],
ListPlot[
annotated,PlotStyle->PointSize[0.01],
PlotLegends->
SwatchLegend[
Automatic,DeleteDuplicates[labels],
LabelStyle->16
]
],
Frame->True,Axes->False,
PlotRangePadding->Scaled[.05],
LabelStyle->Directive[Black,16],
FrameStyle->Black,
FrameLabel->{
Style["PC1 ("<>ToString[Round[100eigenvals[[1]]/Total@eigenvals,0.1]]<>"%)",FontSize->16,Blue],
Style["PC2 ("<>ToString[Round[100eigenvals[[2]]/Total@eigenvals,0.1]]<>"%)",FontSize->16,Red]
},
ImageSize->Large,AspectRatio->1
]
]


(* ::Section::Initialization:: *)
(*removeOutliers: helper function to remove outlier points*)


(* ::Input::Initialization:: *)
removeOutliers::dups="Duplicate sample names found in list of points to remove";
removeOutliers::missing="One of the specified sample names does not exist in the full dataset: check spelling?";

removeOutliers[dataset_?MatrixQ][argseq:{_String,_List}..]:=Module[
{allSamplesInSet,listToRemove,datasetAsAssociation,removalRules},
listToRemove=List@argseq;
allSamplesInSet=DeleteDuplicates[dataset[[2;;,1]]];

(* Check for duplicate sample names in argseq *)
If[Not@*DuplicateFreeQ@listToRemove[[All,1]],Message[removeOutliers::dups];Abort[]];
(* Check for mis-spelled or otherwise non-matching sample names in argseq *)
If[allSamplesInSet~(Not@*ContainsAll)~listToRemove[[All,1]],Message[removeOutliers::missing];Abort[]];

datasetAsAssociation=GroupBy[dataset,First];

removalRules=Join[
AssociationThread[allSamplesInSet->ConstantArray[{},Length@allSamplesInSet]],
AssociationThread[Rule@@Transpose@listToRemove]
];

Join[
{dataset[[1]]},
Flatten[#,1]&@
KeyValueMap[datasetAsAssociation[#1][[Range[Length[datasetAsAssociation[#1]]]~Complement~#2]]&,removalRules]
]
]


(* ::Section::Initialization:: *)
(*overview: generates sparklines for each instrumental variable in the dataset, for quick identification of useless variables*)


(* ::Input::Initialization:: *)
(*The following informs the syntax coloring engine that overview takes only one argument; 
if mistakenly used with more, then the front end will color further arguments in red*)
SyntaxInformation[overview]="ArgumentsPattern"->{_};

overview[data_?MatrixQ]:=
Module[{workingdata},
(*Check for the presence of sample labels, and remove them if present*)
workingdata=If[NumberQ@data[[2,1]],data,data[[All,2;;]]];
Multicolumn[
Framed[
ListPlot[
{##2},
PlotLabel->Style[#1,14,Red],
PlotRangePadding->{Scaled[0.03],{Scaled[0.05],Scaled[0.1]}},
Axes->None,
(*Do not display a frame around the plot area.
Although this is already the default for ListPlot,
let us just make sure, in case the default has been altered*)
Frame->None
]
]&@@@Transpose[workingdata],
Appearance->"Horizontal"
]
]


(* ::Section:: *)
(*projectorLDA : allows the projection of a second data set onto the LDA score plot generated  from the first one*)


(* ::Input::Initialization:: *)
(* The number of variables in the projector and projected set must be the same *)
projectorLDA::incompdims="The number of variables (i.e. columns) in the two sets is not the same.";

(* Base code *)
projectorLDA[projectorSet_?ArrayQ,projectorSuffix_String,projectedSet_?ArrayQ,projectedSuffix_String,options:OptionsPattern[lda]]:=Module[
{
projectedScoresAsTable,projectedScoresAsAssociation,
labelsForProjector,labelsForProjected,projectorSetRelabeled
},

If[Last@Dimensions[projectorSet]!=Last@Dimensions[projectedSet],Message[projectorLDA::incompdims];Abort[]];

(* Extract and modify labels to add suffixes *)
labelsForProjector=StringJoin[#,projectorSuffix]&/@projectorSet[[2;;,1]];
labelsForProjected=StringJoin[#,projectedSuffix]&/@projectedSet[[2;;,1]];

(* Relabel the projector set with the new labels to which the requested suffix has been added *)
projectorSetRelabeled=projectorSet;
projectorSetRelabeled[[2;;,1]]=labelsForProjector;

(* Calculate n-dimensional scores, then remove adventitious imaginary parts (Chop), then keep only first two dimensions *)
projectedScoresAsTable=Chop[
Standardize[ projectedSet[[2;;,2;;]] ] . Transpose[ lda[projectorSetRelabeled,output->"eigenvectors"] ]
][[All,;;2]];

projectedScoresAsAssociation=GroupBy[First->(Tooltip[Last[#],First[#]]&)]@Thread[labelsForProjected->projectedScoresAsTable];

Show[
(* use the usual LDA function to generate a base plot *)
(* this also includes the usual formatting and factor contribution calculations *)
lda[projectorSetRelabeled,output->"2D",ellipsoidcolor->True,options],
(* generate a second plot from the values *)
ListPlot[Values@projectedScoresAsAssociation]
]
]

(* Helper argument patterns that handle the various cases of missing suffixes *)
projectorLDA[projectorSet_?ArrayQ,projectorSuffix_String,projectedSet_?ArrayQ,options:OptionsPattern[lda]]:=projectorLDA[projectorSet,projectorSuffix,projectedSet,"",options]
projectorLDA[projectorSet_?ArrayQ,projectedSet_?ArrayQ,projectedSuffix_String,options:OptionsPattern[lda]]:=projectorLDA[projectorSet,"",projectedSet,projectedSuffix,options]
projectorLDA[projectorSet_?ArrayQ,projectedSet_?ArrayQ,options:OptionsPattern[lda]]:=projectorLDA[projectorSet,"",projectedSet,"",options]


(* ::Section::Initialization:: *)
(*Closing out the package*)


(* ::Input::Initialization:: *)
End[]

Protect[lda,groupcontribs,outlierPCA,outlierPCAauto,plotsfromgrid,selectVarSubsets,filterVars,retainedInfo,effectOfRemovingVariables,pca,removeOutliers,overview,projectorLDA]

EndPackage[]



