(* ::Package:: *)

(* ::Input:: *)
(*data=DeleteCases[Import["C:\\Users\\marco\\Documents\\Alabama\\Students\\Xiyuan Yao\\20220210 Plate_NR_DCIP_MY.xls"][[2]],{"Caffeic Acid",__}];*)


(* ::Input:: *)
(*"heatmap[dataset]\twill produce a heat map plot of the entire dataset to quickly spot unevenness, data quality,\n\t\t\t\t\tobvious outlier points, and information distribution within each instrumental measurement.\n\t\t\t\t\tIn the plot, the data is presented by rows (samples) and columns (measurements).\n\t\t\t\t\tThe data for each measurement type is standardized before plotting so the magnitudes of variation are comparable.\n\nSpecific options:\n\"sortedSet\" -> True\tIf this is set to False, then both the columns and the rows of the dataset are sorted alphabetically before plotting.\n\t\t\t\t\tThe default value (True) does no sorting).\n\nThe function uses ArrayPlot to generate the graphics so it also takes general plotting function / Graphics options such as ColorFunction and ColorFunctionScaling, AspectRatio, Mesh, MeshStyle."*)


(* ::Input:: *)
(*ClearAll[heatmap]*)
(**)
(*Options[heatmap]={*)
(*(* Pass-through options that are typically different from the default for MatrixPlot *)*)
(*AspectRatio->1/2,ImageSize->Full,*)
(*ColorFunction->Automatic,ColorFunctionScaling->True,*)
(*FrameTicksStyle->Directive[Black,9],*)
(*(* the default for plotting functions would be Automatic, rather than the following, but this is more convenient to handle options in the two directions separately *)*)
(*Mesh->{Automatic,None},MeshStyle->{Directive[GrayLevel[0,1],Thick],GrayLevel[0.5,0.5]},*)
(*(* option to decide whether the dataset should be sorted before plotting *)*)
(*"sortedSet"->True*)
(*};*)
(**)
(*heatmap[rawdata_,OptionsPattern[]]:=Module[*)
(*{sortedData,*)
(*measurements,varnames,samplenames,*)
(*meshLines,hMeshLines,vMeshLines,*)
(*ticks*)
(*},*)
(**)
(*Switch[OptionValue["sortedSet"],*)
(*True,sortedData=rawdata,*)
(*_,*)
(*(* In case the data set is not already pre-sorted, the sorting below ensures that: *)*)
(*(* 1) all replicates from same sample are together; *)*)
(*(* 2) measurements from the same sensors are grouped together *)*)
(*(* Point 2 requires that the first part of the measurement name be a sensor label (e.g. "ML A430"), which should be good practice anyway. *)*)
(*(* Both steps use a stable sort, so the original relative order of columns and rows is retained within each grouping: *)*)
(*(* for instance, replicates of the same sample are grouped, but within the group they will be in the same order as they were in the original dataset. *)*)
(*(* The ReplacePart ensures that the top left entry is an empty string, so the first row containins the measurement names will not be moved by Sort. *)*)
(*(* It would be safer to explicitly remove the first row before the first Sort, and re-append it later, but this should work as well. *)*)
(*sortedData=*)
(*Transpose@*)
(*SortBy[{First}]@Transpose@*)
(*SortBy[{First}]@*)
(*ReplacePart[rawdata,{1,1}->""]*)
(*];*)
(**)
(*measurements=sortedData[[2;;,2;;]];*)
(*varnames=sortedData[[1,2;;]];*)
(*samplenames=sortedData[[2;;,1]];*)
(**)
(*(* Position horizontal mesh lines between sets of replicates *)*)
(*(* Find the first occurrence of each sample name, then substract 1 because the mesh positions start at zero *)*)
(*(* For completeness, also add a line at the last position (the Join part) *)*)
(*hMeshLines=(Values[First/@PositionIndex[samplenames]]-1)~Join~{Length[samplenames]};*)
(*vMeshLines=Range[0,Length[varnames]];*)
(**)
(*meshLines=Switch[OptionValue[Mesh],*)
(*Automatic|{Automatic,Automatic},{hMeshLines,vMeshLines},*)
(*{Automatic,_},{hMeshLines,OptionValue[Mesh][[2]]},*)
(*{_,Automatic},{OptionValue[Mesh][[1]],vMeshLines},*)
(*_,OptionValue[Mesh]*)
(*];*)
(**)
(*(* Tick positions and labels *)*)
(*ticks=Module[{hTicks,vTicks},*)
(*hTicks=Transpose@{Range@Length[varnames],Rotate[#,90Degree]&/@varnames};*)
(*(* for vertical ticks, the Append part specifies outward-facing ("negative") tick marks but no inward-facing ones ("positive") *)*)
(*vTicks=Append[#,{0,0.003}]&/@Transpose@{MovingAverage[hMeshLines,2]+0.5,DeleteDuplicates[samplenames]};*)
(*{{vTicks,vTicks},{hTicks,hTicks}}(* {{left, right},{bottom, top}} *)*)
(*];*)
(**)
(*(* Generate the plot *)*)
(*MatrixPlot[*)
(*Standardize@measurements,*)
(*ColorFunction->OptionValue[ColorFunction],ColorFunctionScaling->OptionValue[ColorFunctionScaling],*)
(*PlotLegends->Placed[Automatic,Top],*)
(*ImageSize->OptionValue[ImageSize],*)
(*PlotRangePadding->None,*)
(*FrameTicks->ticks,FrameTicksStyle->OptionValue[FrameTicksStyle],*)
(*AspectRatio->OptionValue[AspectRatio],*)
(*Mesh->meshLines,MeshStyle->OptionValue[MeshStyle]*)
(*]*)
(*]*)
(**)
(*heatmap[outlierPCA[#,method->"Recursive",output->"CleanedSet"]&@DeleteCases[xy20220210,{"Caffeic Acid",__}],ColorFunction->"AvocadoColors",Mesh->{Automatic,{#,Directive[Thick,GrayLevel[0,1]]}&/@{0,30,42,54,84,96,107,137,161}}]*)
